Add the following logic to SFC2.

Input Format: 

Paths in Model 1 with NO equivalent path in Model 2
From	      To	        Transitions	    Z3 Condition	   Z3 Data Transformation

From	To	Transitions	Condition	Data Transformation
ConvertLoop	BuildHex	['t_7']	(>= i 0)	(and (= TempHex TempDecValue mod 16) (= HexValue (+ (* HexValue 16) TempHex)) (= TempDecValue (/ TempDecValue 16)))

Here is the current SFC2 Python code:
steps2 = [{'name': 'Init', 'function': 'HexValue := 0; TempDecValue := DecValue; i := 9'}, {'name': 'CheckZero', 'function': ''}, {'name': 'SetZero', 'function': 'HexValue := 0; Convert := 1'}, {'name': 'CheckRange', 'function': ''}, {'name': 'SetError', 'function': 'HexValue := -1; Convert := 0'}, {'name': 'ConvertLoop', 'function': ''}, {'name': 'BuildHex', 'function': 'TempHex := TempDecValue mod 15; HexValue := HexValue * 16 + TempHex; TempDecValue := TempDecValue / 16'}, {'name': 'CheckExit', 'function': ''}, {'name': 'SetSuccess', 'function': 'Convert := 1'}, {'name': 'End', 'function': ''}]
transitions2 = [{'src': 'Init', 'tgt': 'CheckZero', 'guard': 'init'}, {'src': 'CheckZero', 'tgt': 'SetZero', 'guard': 'DecValue = 0'}, {'src': 'SetZero', 'tgt': 'End', 'guard': '1'}, {'src': 'CheckZero', 'tgt': 'CheckRange', 'guard': 'DecValue <> 0'}, {'src': 'CheckRange', 'tgt': 'SetError', 'guard': 'DecValue > 9999999999'}, {'src': 'SetError', 'tgt': 'End', 'guard': '1'}, {'src': 'CheckRange', 'tgt': 'ConvertLoop', 'guard': 'DecValue <= 9999999999'}, {'src': 'ConvertLoop', 'tgt': 'BuildHex', 'guard': 'i >= 0'}, {'src': 'BuildHex', 'tgt': 'CheckExit', 'guard': '(TempDecValue mod 16) >= 0'}, {'src': 'CheckExit', 'tgt': 'SetSuccess', 'guard': 'TempDecValue = 0'}, {'src': 'SetSuccess', 'tgt': 'End', 'guard': '1'}, {'src': 'CheckExit', 'tgt': 'ConvertLoop', 'guard': 'TempDecValue <> 0; i := i - 1'}, {'src': 'ConvertLoop', 'tgt': 'BuildHex', 'guard': '(>= i 0)'}, {'src': 'ConvertLoop', 'tgt': 'BuildHex', 'guard': '(>= i 0) and (and (= TempHex TempDecValue mod 16) (= HexValue (+ (* HexValue 16) TempHex)) (= TempDecValue (/ TempDecValue 16)))'}]

Here is the SFC1 Python code for reference:
steps1 = [{'name': 'Init', 'function': "HexValue := ''; TempDecValue := DecValue; i := 9"}, {'name': 'CheckZero', 'function': ''}, {'name': 'SetZero', 'function': "HexValue := '0'; Convert := True"}, {'name': 'CheckRange', 'function': ''}, {'name': 'SetError', 'function': "HexValue := 'Error'; Convert := False"}, {'name': 'ConvertLoop', 'function': ''}, {'name': 'BuildHex', 'function': 'TempHex := TempDecValue mod 16; HexValue := HexValue * 16 + TempHex; TempDecValue := TempDecValue / 16'}, {'name': 'CheckExit', 'function': ''}, {'name': 'SetSuccess', 'function': 'Convert := True'}, {'name': 'End', 'function': ''}]
transitions1 = [{'src': 'Init', 'tgt': 'CheckZero', 'guard': 'init'}, {'src': 'CheckZero', 'tgt': 'SetZero', 'guard': 'DecValue = 0'}, {'src': 'SetZero', 'tgt': 'End', 'guard': 'True'}, {'src': 'CheckZero', 'tgt': 'CheckRange', 'guard': 'DecValue <> 0'}, {'src': 'CheckRange', 'tgt': 'SetError', 'guard': 'DecValue > 9999999999'}, {'src': 'SetError', 'tgt': 'End', 'guard': 'True'}, {'src': 'CheckRange', 'tgt': 'ConvertLoop', 'guard': 'DecValue <= 9999999999'}, {'src': 'ConvertLoop', 'tgt': 'BuildHex', 'guard': 'i >= 0'}, {'src': 'BuildHex', 'tgt': 'CheckExit', 'guard': 'True'}, {'src': 'CheckExit', 'tgt': 'SetSuccess', 'guard': 'TempDecValue = 0'}, {'src': 'SetSuccess', 'tgt': 'End', 'guard': 'True'}, {'src': 'CheckExit', 'tgt': 'ConvertLoop', 'guard': 'TempDecValue <> 0; i := i - 1'}]

Please modify steps2 and transitions2 so that all above paths are covered and equivalence will hold. 
Only output valid Python code for steps2 and transitions2, nothing else.